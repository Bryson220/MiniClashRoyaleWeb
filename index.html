<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clash Royale Lite</title>
<style>
  html, body {margin:0; padding:0; background:#2c7a2c; overflow:hidden;}
  canvas {display:block; margin:0 auto; background:linear-gradient(#3fa63f 40%, #2e8b57 50%, #3fa63f 60%);}
  #ui {
    position:absolute; top:10px; left:50%; transform:translateX(-50%);
    color:white; text-align:center; font-family:sans-serif;
  }
  #elixirBar {width:300px; height:20px; border:2px solid white; margin:5px auto; background:purple;}
  #elixirFill {height:100%; background:violet; width:0%;}
</style>
</head>
<body>
<div id="ui">
  <h2>Clash Royale Lite</h2>
  <div id="elixirBar"><div id="elixirFill"></div></div>
  <div>Player HP: <span id="playerHP"></span> | AI HP: <span id="aiHP"></span></div>
</div>
<canvas id="game" width="600" height="800"></canvas>

<script>
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');
const width=canvas.width, height=canvas.height;
const riverY=height/2;
const bridgeWidth=80, bridgeGap=150;

// Tower setup
const towers={
  player:{
    king:{x:width/2, y:height-100, hp:5000, isTower:true, type:"king", range:200, cooldown:0, active:false},
    left:{x:width/2-120, y:height-220, hp:2000, isTower:true, type:"princess", range:180, cooldown:0},
    right:{x:width/2+120, y:height-220, hp:2000, isTower:true, type:"princess", range:180, cooldown:0}
  },
  ai:{
    king:{x:width/2, y:100, hp:5000, isTower:true, type:"king", range:200, cooldown:0, active:false},
    left:{x:width/2-120, y:220, hp:2000, isTower:true, type:"princess", range:180, cooldown:0},
    right:{x:width/2+120, y:220, hp:2000, isTower:true, type:"princess", range:180, cooldown:0}
  }
};

const units=[];
const projectiles=[];
let elixir=5, aiElixir=5;
const elixirFill=document.getElementById("elixirFill");
const playerHP=document.getElementById("playerHP");
const aiHP=document.getElementById("aiHP");
let lastSpawn=0, aiLastSpawn=0;
const elixirRate=2.8*1000; // 1 elixir every 2.8s

// Card data
const cards=[
  {id:"knight",shape:"circle",color:"blue",speed:1.2,range:25,damage:50,hp:300,cost:3,target:"any",type:"melee"},
  {id:"archer",shape:"triangle",color:"cyan",speed:1.0,range:120,damage:35,hp:150,cost:3,target:"any",type:"ranged",attackSpeed:1000},
  {id:"giant",shape:"square",color:"orange",speed:0.8,range:30,damage:80,hp:500,cost:5,target:"tower",type:"melee"}
];

function distance(a,b){return Math.hypot(a.x-b.x,a.y-b.y);}
function drawHealthBar(x,y,cur,max){
  ctx.fillStyle="red";ctx.fillRect(x-15,y-25,30,4);
  ctx.fillStyle="lime";ctx.fillRect(x-15,y-25,30*(cur/max),4);
}

function spawnUnit(side, card){
  const y=side==="player"?height-180:180;
  const lane=Math.random()<0.5?"left":"right";
  const x=lane==="left"?width/2-bridgeGap/2:width/2+bridgeGap/2;
  units.push({
    side,card,
    x:x+(Math.random()*40-20),y:y+(Math.random()*20-10),
    hp:card.hp,target:null,bridgeCrossed:false,lastAttack:0
  });
}

function updateElixir(dt){
  if(Date.now()-lastSpawn>elixirRate && elixir<10){elixir++;lastSpawn=Date.now();}
  if(Date.now()-aiLastSpawn>elixirRate && aiElixir<10){aiElixir++;aiLastSpawn=Date.now();}
  elixirFill.style.width=(elixir/10*100)+"%";
}

function spawnProjectile(x,y,target,damage,side,speed=4,color="yellow"){
  projectiles.push({x,y,target,damage,side,speed,color});
}

// --- UNIT LOGIC ---
function updateUnits(dt){
  for(let u of units){
    const enemies=units.filter(e=>e.side!==u.side);
    const towerSet=u.side==="player"?towers.ai:towers.player;
    const allEnemyTowers=[towerSet.king,towerSet.left,towerSet.right];

    // River logic
    if(!u.bridgeCrossed){
      if(u.side==="player" && u.y>riverY-40) u.y-=u.card.speed;
      else if(u.side==="ai" && u.y<riverY+40) u.y+=u.card.speed;
      if(Math.abs(u.y-riverY)<=40){
        if(Math.abs(u.x-width/2)<=bridgeGap/2+bridgeWidth/2) u.bridgeCrossed=true;
        else u.x += u.x<width/2?0.5:-0.5;
      }
      continue;
    }

    // Targeting
    let closest=null,dist=Infinity;
    for(let e of enemies){
      const d=distance(u,e);
      if(d<dist){dist=d;closest=e;}
    }

    let towerTarget=null, towerDist=Infinity;
    for(let t of allEnemyTowers){
      const d=distance(u,t);
      if(d<towerDist){towerDist=d;towerTarget=t;}
    }

    if(u.card.id==="giant"){
      u.target=towerTarget;
    } else {
      if(closest && dist<=u.card.range) u.target=closest;
      else u.target=towerTarget;
    }

    // Movement / attack
    if(u.target){
      const dx=u.target.x-u.x, dy=u.target.y-u.y;
      const d=Math.hypot(dx,dy);
      if(d>u.card.range){
        u.x+=dx/d*u.card.speed;
        u.y+=dy/d*u.card.speed;
      } else {
        if(u.card.type==="melee"){
          u.target.hp-=u.card.damage*dt/1000;
        } else if(u.card.type==="ranged"){
          if(Date.now()-u.lastAttack>u.card.attackSpeed){
            spawnProjectile(u.x,u.y,u.target,u.card.damage,u.side,5,"cyan");
            u.lastAttack=Date.now();
          }
        }
      }
    }
  }

  for(let i=units.length-1;i>=0;i--) if(units[i].hp<=0) units.splice(i,1);
}

// --- TOWER LOGIC ---
function updateTowers(dt){
  const allTowers=[...Object.values(towers.player),...Object.values(towers.ai)];

  // Activate King Towers if princesses destroyed
  for(const side of ["player","ai"]){
    const set=towers[side];
    if((set.left.hp<=0 && set.right.hp<=0) && !set.king.active){
      set.king.active=true;
    }
  }

  for(let t of allTowers){
    if(t.hp<=0) continue;
    if(t.type==="king" && !t.active) continue; // inactive kings skip

    const enemies=units.filter(u=>u.side===(t.y<height/2?"player":"ai"));
    let closest=null,dist=Infinity;
    for(let e of enemies){
      const d=distance(t,e);
      if(d<t.range && d<dist){dist=d;closest=e;}
    }
    if(closest && Date.now()-t.cooldown>1000){
      spawnProjectile(t.x,t.y,closest,(t.type==="king"?120:100),(t.y<height/2?"ai":"player"),6,"orange");
      t.cooldown=Date.now();
    }
  }
}

// --- PROJECTILES ---
function updateProjectiles(dt){
  for(let p of projectiles){
    const dx=p.target.x-p.x, dy=p.target.y-p.y;
    const d=Math.hypot(dx,dy);
    if(d<8){
      p.target.hp-=p.damage;
      p.remove=true;
      continue;
    }
    p.x+=dx/d*p.speed; p.y+=dy/d*p.speed;
  }
  for(let i=projectiles.length-1;i>=0;i--) if(projectiles[i].remove||projectiles[i].y<0||projectiles[i].y>height) projectiles.splice(i,1);
}

// --- DRAW ---
function draw(){
  ctx.clearRect(0,0,width,height);
  ctx.fillStyle="#3fa63f"; ctx.fillRect(0,0,width,riverY-40); ctx.fillRect(0,riverY+40,width,height);
  ctx.fillStyle="#3b75ff"; ctx.fillRect(0,riverY-40,width,80);
  ctx.fillStyle="#8b4513";
  ctx.fillRect(width/2-bridgeGap/2-bridgeWidth/2,riverY-40,bridgeWidth,80);
  ctx.fillRect(width/2+bridgeGap/2-bridgeWidth/2,riverY-40,bridgeWidth,80);

  const allTowers=[...Object.values(towers.player),...Object.values(towers.ai)];
  for(let t of allTowers){
    ctx.fillStyle=(t.y>height/2)?"blue":"red";
    if(t.type==="king"){ctx.beginPath();ctx.arc(t.x,t.y,25,0,Math.PI*2);ctx.fill();}
    else {ctx.fillRect(t.x-20,t.y-20,40,40);}
    drawHealthBar(t.x,t.y,t.hp,(t.type==="king"?5000:2000));
  }

  for(let u of units){
    ctx.fillStyle=u.card.color;
    if(u.card.shape==="circle"){ctx.beginPath();ctx.arc(u.x,u.y,10,0,Math.PI*2);ctx.fill();}
    if(u.card.shape==="square"){ctx.fillRect(u.x-10,u.y-10,20,20);}
    if(u.card.shape==="triangle"){ctx.beginPath();ctx.moveTo(u.x,u.y-10);ctx.lineTo(u.x-10,u.y+10);ctx.lineTo(u.x+10,u.y+10);ctx.closePath();ctx.fill();}
    drawHealthBar(u.x,u.y,u.hp,u.card.hp);
  }

  ctx.fillStyle="yellow";
  for(let p of projectiles){ctx.beginPath();ctx.arc(p.x,p.y,3,0,Math.PI*2);ctx.fill();}
}

function aiLogic(){
  if(aiElixir>=3+Math.random()*3 && Math.random()<0.02){
    const card=cards[Math.floor(Math.random()*cards.length)];
    if(aiElixir>=card.cost){spawnUnit("ai",card);aiElixir-=card.cost;}
  }
}

// --- MAIN LOOP ---
let lastTime=performance.now();
function loop(t){
  const dt=t-lastTime; lastTime=t;
  updateElixir(dt);
  aiLogic();
  updateUnits(dt);
  updateTowers(dt);
  updateProjectiles(dt);
  draw();
  playerHP.textContent=Math.round(towers.player.king.hp);
  aiHP.textContent=Math.round(towers.ai.king.hp);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

canvas.addEventListener("click",()=>{
  const card=cards[Math.floor(Math.random()*cards.length)];
  if(elixir>=card.cost){spawnUnit("player",card);elixir-=card.cost;}
});
</script>
</body>
</html>
