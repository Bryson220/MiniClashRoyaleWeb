<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clash Royale Lite</title>
<style>
  body {
    margin: 0;
    background: #87CEEB;
    overflow: hidden;
  }
  canvas {
    display: block;
    margin: auto;
    background: #4caf50;
  }
  .ui {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 10px;
  }
  .card {
    width: 80px;
    height: 100px;
    background: #ddd;
    border-radius: 10px;
    border: 2px solid #333;
    text-align: center;
    font-family: sans-serif;
    cursor: pointer;
    user-select: none;
  }
  .selected {
    border-color: gold;
    background: #fff6a8;
  }
  .elixir {
    position: absolute;
    bottom: 120px;
    left: 50%;
    transform: translateX(-50%);
    width: 300px;
    height: 20px;
    border: 2px solid #222;
    border-radius: 10px;
    background: #ccc;
    overflow: hidden;
  }
  .elixir-fill {
    height: 100%;
    background: purple;
    width: 0%;
    transition: width 0.5s linear;
  }
</style>
</head>
<body>
<canvas id="game" width="600" height="900"></canvas>

<div class="elixir">
  <div class="elixir-fill" id="elixirFill"></div>
</div>

<div class="ui">
  <div class="card" id="knightCard">‚öîÔ∏è<br>Knight<br>3</div>
  <div class="card" id="archerCard">üèπ<br>Archer<br>3</div>
  <div class="card" id="giantCard">üí™<br>Giant<br>5</div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const WIDTH = canvas.width;
const HEIGHT = canvas.height;

// map zones
const riverY = HEIGHT / 2 - 30;
const bridgeWidth = 80;

// game state
let troops = [];
let aiTroops = [];
let elixir = 10;
let selectedCard = null;
let lastElixirTime = Date.now();

// tower objects
const towers = {
  playerKing: {x: WIDTH/2 - 25, y: HEIGHT - 100, w: 50, h: 50, hp: 5000},
  playerLeft: {x: WIDTH/2 - 150, y: HEIGHT - 200, w: 40, h: 40, hp: 2000},
  playerRight: {x: WIDTH/2 + 110, y: HEIGHT - 200, w: 40, h: 40, hp: 2000},
  enemyKing: {x: WIDTH/2 - 25, y: 50, w: 50, h: 50, hp: 5000},
  enemyLeft: {x: WIDTH/2 - 150, y: 150, w: 40, h: 40, hp: 2000},
  enemyRight: {x: WIDTH/2 + 110, y: 150, w: 40, h: 40, hp: 2000},
};

// troop types
const troopTypes = {
  Knight: {color: "blue", hp: 400, damage: 40, range: 20, speed: 1, cost: 3, target: "any"},
  Archer: {color: "purple", hp: 250, damage: 30, range: 100, speed: 1.5, cost: 3, target: "any"},
  Giant: {color: "orange", hp: 900, damage: 80, range: 15, speed: 0.6, cost: 5, target: "tower"}
};

class Troop {
  constructor(type, x, y, isAI) {
    Object.assign(this, troopTypes[type]);
    this.type = type;
    this.x = x;
    this.y = y;
    this.isAI = isAI;
    this.hp = this.hp;
  }
  draw() {
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, 15, 0, Math.PI*2);
    ctx.fill();
    // health bar
    ctx.fillStyle = "red";
    ctx.fillRect(this.x - 15, this.y - 25, 30, 4);
    ctx.fillStyle = "lime";
    ctx.fillRect(this.x - 15, this.y - 25, 30 * (this.hp / troopTypes[this.type].hp), 4);
  }
  update() {
    const enemies = this.isAI ? troops : aiTroops;
    let target = null;

    // find closest enemy troop or tower
    if (this.target === "any") {
      target = this.findClosest(enemies.concat(Object.values(towers).filter(t => t.isAI !== this.isAI)));
    } else {
      target = this.findClosest(Object.values(towers).filter(t => t.isAI !== this.isAI));
    }

    if (target) {
      const dx = target.x - this.x;
      const dy = target.y - this.y;
      const dist = Math.hypot(dx, dy);

      if (dist > this.range + 10) {
        const nx = dx / dist;
        const ny = dy / dist;
        // prevent crossing river except bridge area
        if ((this.isAI && this.y < riverY + 30) || (!this.isAI && this.y > riverY + 30)) {
          if (Math.abs(this.x - WIDTH/2) < bridgeWidth/2) {
            this.x += nx * this.speed;
            this.y += ny * this.speed;
          }
        } else {
          this.x += nx * this.speed;
          this.y += ny * this.speed;
        }
      } else {
        // attack
        target.hp -= this.damage * 0.05;
      }
    }
  }
  findClosest(targets) {
    let min = Infinity, closest = null;
    for (const t of targets) {
      const dx = (t.x || (t.x = t.x)) - this.x;
      const dy = (t.y || (t.y = t.y)) - this.y;
      const dist = Math.hypot(dx, dy);
      if (dist < min) { min = dist; closest = t; }
    }
    return closest;
  }
}

function drawMap() {
  ctx.fillStyle = "#4caf50";
  ctx.fillRect(0, 0, WIDTH, HEIGHT);
  ctx.fillStyle = "#3399ff";
  ctx.fillRect(0, riverY, WIDTH, 60);
  ctx.fillStyle = "#8b5a2b";
  ctx.fillRect(WIDTH/2 - bridgeWidth/2, riverY, bridgeWidth, 60);
}

function drawTowers() {
  for (const [key, t] of Object.entries(towers)) {
    ctx.fillStyle = key.includes("player") ? "#444" : "#a00";
    ctx.fillRect(t.x, t.y, t.w, t.h);
    ctx.fillStyle = "red";
    ctx.fillRect(t.x, t.y - 8, t.w, 5);
    ctx.fillStyle = "lime";
    ctx.fillRect(t.x, t.y - 8, t.w * (t.hp / (key.includes("King") ? 5000 : 2000)), 5);
  }
}

function gameLoop() {
  ctx.clearRect(0, 0, WIDTH, HEIGHT);
  drawMap();
  drawTowers();

  troops.forEach(t => t.update());
  aiTroops.forEach(t => t.update());
  troops.forEach(t => t.draw());
  aiTroops.forEach(t => t.draw());

  // clean up dead units
  troops = troops.filter(t => t.hp > 0);
  aiTroops = aiTroops.filter(t => t.hp > 0);

  // AI spawn logic
  if (Math.random() < 0.005 && aiTroops.length < 6) {
    const type = ["Knight", "Archer", "Giant"][Math.floor(Math.random()*3)];
    aiTroops.push(new Troop(type, WIDTH/2 + (Math.random() * 150 - 75), 120, true));
  }

  // elixir regen
  const now = Date.now();
  if (now - lastElixirTime > 2800 && elixir < 10) {
    elixir += 1;
    lastElixirTime = now;
  }
  document.getElementById('elixirFill').style.width = (elixir * 10) + "%";

  requestAnimationFrame(gameLoop);
}
gameLoop();

// placing troops
canvas.addEventListener('click', e => {
  if (!selectedCard) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  if (y > HEIGHT/2 + 30 && elixir >= troopTypes[selectedCard].cost) {
    troops.push(new Troop(selectedCard, x, y, false));
    elixir -= troopTypes[selectedCard].cost;
  }
});

// card selection
function selectCard(type) {
  selectedCard = type;
  document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
  document.getElementById(type.toLowerCase() + 'Card').classList.add('selected');
}
document.getElementById('knightCard').onclick = () => selectCard("Knight");
document.getElementById('archerCard').onclick = () => selectCard("Archer");
document.getElementById('giantCard').onclick = () => selectCard("Giant");
</script>
</body>
</html>
