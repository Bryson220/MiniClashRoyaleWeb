<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Clash Royale Lite</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #87CEEB;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: linear-gradient(#77b255, #5ca35c);
      border: 2px solid #333;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="600" height="800"></canvas>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // Game constants
    const MAP_WIDTH = 600;
    const MAP_HEIGHT = 800;
    const ELIXIR_REGEN = 2.8 * 60; // 2.8 seconds per elixir (at 60 FPS)
    const BRIDGE_Y = 400; // middle bridges

    const cards = {
      knight: { id: "knight", hp: 600, dmg: 40, range: 30, speed: 1.5, color: "blue", cost: 3 },
      archer: { id: "archer", hp: 250, dmg: 30, range: 120, speed: 1.8, color: "purple", cost: 3 },
      giant: { id: "giant", hp: 1200, dmg: 80, range: 25, speed: 1, color: "brown", cost: 5 }
    };

    const towers = {
      player: { x: MAP_WIDTH / 2, y: MAP_HEIGHT - 100, hp: 5000 },
      ai: { x: MAP_WIDTH / 2, y: 100, hp: 5000 }
    };

    let playerElixir = 5;
    let aiElixir = 5;
    let frameCount = 0;
    let units = [];

    function distance(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function drawTower(t) {
      ctx.fillStyle = "#444";
      ctx.fillRect(t.x - 25, t.y - 25, 50, 50);
      ctx.fillStyle = "red";
      ctx.fillRect(t.x - 25, t.y - 40, 50 * (t.hp / 5000), 5);
    }

    function drawBridge() {
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(150, BRIDGE_Y - 10, 100, 20);
      ctx.fillRect(350, BRIDGE_Y - 10, 100, 20);
    }

    function spawnUnit(side, card, x, y) {
      if (side === "player" && playerElixir < card.cost) return;
      if (side === "ai" && aiElixir < card.cost) return;

      const newUnit = {
        ...card,
        side,
        x,
        y,
        hp: card.hp,
        target: null
      };
      units.push(newUnit);

      if (side === "player") playerElixir -= card.cost;
      else aiElixir -= card.cost;
    }

    function updateUnits() {
      for (let u of units) {
        const enemies = units.filter(e => e.side !== u.side);
        let enemyTower = u.side === "player" ? towers.ai : towers.player;

        // GIANT targets tower directly
        if (u.id === "giant") {
          u.target = enemyTower;
        } else {
          // find nearest enemy
          let closest = null, distClosest = Infinity;
          for (let e of enemies) {
            const d = distance(u, e);
            if (d < distClosest && d <= u.range * 2) {
              distClosest = d;
              closest = e;
            }
          }
          if (closest) u.target = closest;
          else if (distance(u, enemyTower) < 600) u.target = enemyTower;
        }

        // movement & attacking
        if (u.target) {
          const d = distance(u, u.target);
          if (d > u.range) {
            const dx = (u.target.x - u.x) / d;
            const dy = (u.target.y - u.y) / d;
            u.x += dx * u.speed;
            u.y += dy * u.speed;
          } else {
            // attack
            u.target.hp -= u.dmg * 0.05;
            if (u.target.hp <= 0) {
              if (u.target.isTower) u.target.hp = 0;
              else units = units.filter(e => e !== u.target);
            }
          }
        }
      }
    }

    function drawUnits() {
      for (let u of units) {
        ctx.beginPath();
        if (u.id === "knight") ctx.rect(u.x - 10, u.y - 10, 20, 20);
        else if (u.id === "archer") ctx.arc(u.x, u.y, 10, 0, Math.PI * 2);
        else if (u.id === "giant") ctx.rect(u.x - 15, u.y - 15, 30, 30);
        ctx.fillStyle = u.side === "player" ? u.color : "red";
        ctx.fill();
      }
    }

    function aiLogic() {
      if (Math.random() < 0.01 && aiElixir >= 3) {
        const cardKeys = Object.keys(cards);
        const c = cards[cardKeys[Math.floor(Math.random() * cardKeys.length)]];
        spawnUnit("ai", c, 200 + Math.random() * 200, 200);
      }
    }

    function gameLoop() {
      ctx.clearRect(0, 0, MAP_WIDTH, MAP_HEIGHT);
      drawBridge();
      drawTower(towers.player);
      drawTower(towers.ai);
      drawUnits();

      frameCount++;
      if (frameCount % ELIXIR_REGEN === 0) {
        if (playerElixir < 10) playerElixir++;
        if (aiElixir < 10) aiElixir++;
      }

      updateUnits();
      aiLogic();

      // Elixir display
      ctx.fillStyle = "white";
      ctx.font = "18px Arial";
      ctx.fillText("Elixir: " + playerElixir.toFixed(0), 20, MAP_HEIGHT - 20);

      requestAnimationFrame(gameLoop);
    }

    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const chosen = cards.knight; // spawn Knight by default
      spawnUnit("player", chosen, x, y);
    });

    gameLoop();
  </script>
</body>
</html>
