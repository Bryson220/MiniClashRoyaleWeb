<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mini Clash Royale Stable</title>
<style>
body { margin:0; background-color:#87CEEB; font-family:Arial,sans-serif; user-select:none; overflow:hidden; }
#gameArea { position: relative; width: 400px; height: 800px; margin: auto; background-color: #7CFC00; border:2px solid #000; }

.tower, .unit { position: absolute; display:flex; justify-content:center; align-items:center; }
.hpBar { position:absolute; top:-8px; left:0; height:6px; width:100%; background-color:green; border:1px solid #000; }
#elixirBar { position:absolute; bottom:0; left:50%; transform:translateX(-50%); font-weight:bold; font-size:16px; background: rgba(0,0,0,0.5); color:#fff; padding:5px 10px; border-radius:5px; }
#cards { position:absolute; bottom:50px; left:50%; transform:translateX(-50%); display:flex; }
.card { width:60px; height:60px; margin:5px; border:2px solid black; border-radius:5px; background-color:#fff; display:flex; justify-content:center; align-items:center; cursor:grab; font-weight:bold; }

/* Shapes */
.shape-square { width:50px; height:50px; background:red; }
.shape-circle { width:50px; height:50px; background:blue; border-radius:50%; }
.shape-triangle { width:0; height:0; border-left:25px solid transparent; border-right:25px solid transparent; border-bottom:50px solid green; }
.shape-king-tower { width:60px; height:60px; background:black; }
.shape-princess-tower { width:40px; height:40px; background:purple; }

/* Water & Bridges */
#river { position:absolute; top:350px; left:0; width:400px; height:100px; background-color:#1E90FF; }
.bridge-left { position:absolute; top:350px; left:50px; width:80px; height:100px; background-color:#8B4513; }
.bridge-right { position:absolute; top:350px; left:270px; width:80px; height:100px; background-color:#8B4513; }
</style>
</head>
<body>
<div id="gameArea">
  <div id="river"></div>
  <div class="bridge-left"></div>
  <div class="bridge-right"></div>
</div>
<div id="elixirBar">Elixir: 10</div>
<div id="cards"></div>

<script>
// Constants
const GAME_WIDTH = 400;
const GAME_HEIGHT = 800;
const MAX_ELIXIR = 10;
const ELIXIR_REGEN = 1;
const BRIDGES = [{x:50,width:80},{x:270,width:80}];

// Elements
const gameArea = document.getElementById('gameArea');
const elixirBar = document.getElementById('elixirBar');
const cardsDiv = document.getElementById('cards');

// Player & AI
let playerElixir = MAX_ELIXIR;
let aiElixir = MAX_ELIXIR;
let playerUnits = [];
let aiUnits = [];

// Cards
const cardsData = [
  {name:'Knight', cost:3, hp:400, dmg:25, speed:1.2, range:30, type:'square'},
  {name:'Archer', cost:3, hp:150, dmg:15, speed:1.5, range:80, type:'circle'},
  {name:'Giant', cost:5, hp:1000, dmg:35, speed:0.7, range:30, type:'triangle'}
];

// Towers
let towers = {
  playerKing: {x: GAME_WIDTH/2-30, y:GAME_HEIGHT-80, hp:5000, type:'king', element:null},
  aiKing: {x: GAME_WIDTH/2-30, y:20, hp:5000, type:'king', element:null},
  playerLeft: {x: GAME_WIDTH/2-100, y:GAME_HEIGHT-140, hp:2000, type:'princess', element:null},
  playerRight: {x: GAME_WIDTH/2+60, y:GAME_HEIGHT-140, hp:2000, type:'princess', element:null},
  aiLeft: {x: GAME_WIDTH/2-100, y:100, hp:2000, type:'princess', element:null},
  aiRight: {x: GAME_WIDTH/2+60, y:100, hp:2000, type:'princess', element:null}
};

// Create towers
function createTower(tower){
  const div=document.createElement('div');
  div.className='tower '+(tower.type==='king'?'shape-king-tower':'shape-princess-tower');
  div.style.left=tower.x+'px';
  div.style.top=tower.y+'px';
  const hp=document.createElement('div');
  hp.className='hpBar';
  div.appendChild(hp);
  gameArea.appendChild(div);
  tower.element=div;
}
for(const t in towers) createTower(towers[t]);

// Create card buttons
cardsData.forEach(card=>{
  const div=document.createElement('div');
  div.className='card';
  div.innerText=card.name;
  div.draggable=true;
  div.addEventListener('dragstart',e=>dragStart(e,card));
  cardsDiv.appendChild(div);
});

// Drag & Drop
let draggingCard = null;
function dragStart(e,card){draggingCard=card;}
gameArea.addEventListener('dragover',e=>e.preventDefault());
gameArea.addEventListener('drop',e=>{
  e.preventDefault();
  if(!draggingCard || playerElixir<draggingCard.cost) return;
  const rect=gameArea.getBoundingClientRect();
  const x=e.clientX-rect.left;
  const y=e.clientY-rect.top;
  if(y>GAME_HEIGHT/2) spawnUnit('player',draggingCard,{x,y});
  draggingCard=null;
});

// Spawn units
function spawnUnit(side,card,pos){
  const unit={
    id:Math.random().toString(36).substr(2,9),
    x:pos.x, y:pos.y,
    card, hp:card.hp, side, target:null
  };
  const div=document.createElement('div');
  div.className='unit shape-'+card.type;
  const hp=document.createElement('div');
  hp.className='hpBar';
  div.appendChild(hp);
  gameArea.appendChild(div);
  unit.element=div;
  if(side==='player') playerUnits.push(unit), playerElixir-=card.cost;
  else aiUnits.push(unit), aiElixir-=card.cost;
}

// Elixir
function updateElixir(){elixirBar.innerText=`Elixir: ${playerElixir}`;}

// Distance
function distance(a,b){return Math.hypot(a.x-b.x,a.y-b.y);}

// Find target
function findTarget(unit,enemyUnits,enemyTowers){
  let closest=null,dist=Infinity;
  enemyUnits.forEach(u=>{const d=distance(unit,u); if(d<dist){closest=u; dist=d;}});
  if(closest) return closest;
  const towerList=unit.side==='player'?Object.values(towers).filter(t=>t.y<400):Object.values(towers).filter(t=>t.y>400);
  let closestTower=null,distTower=Infinity;
  towerList.forEach(t=>{const d=distance(unit,t); if(d<distTower){closestTower=t; distTower=d;}});
  return closestTower;
}

// Update units
function updateUnits(units,enemyUnits,enemyTowers){
  units.forEach(u=>{
    if(u.hp<=0){u.element.remove(); return;}
    let target=findTarget(u,enemyUnits,enemyTowers);
    const dist=distance(u,target);
    if(dist<u.card.range){
      target.hp-=u.card.dmg*0.05;
      if(target.element){
        const maxHP=(target.type==='king')?5000:2000;
        target.element.querySelector('.hpBar').style.width=(target.hp/maxHP*100)+'%';
      }
    } else {
      // Move toward target
      const dx=target.x-u.x, dy=target.y-u.y, d=Math.hypot(dx,dy);
      u.x+=dx/d*u.card.speed;
      u.y+=dy/d*u.card.speed;
    }
    u.element.style.left=u.x+'px';
    u.element.style.top=u.y+'px';
  });
  for(let i=units.length-1;i>=0;i--) if(units[i].hp<=0) units.splice(i,1);
}

// AI
setInterval(()=>{
  if(aiElixir>=3){
    const card=cardsData[Math.floor(Math.random()*cardsData.length)];
    const bridge=BRIDGES[Math.floor(Math.random()*BRIDGES.length)];
    spawnUnit('ai',card,{x:bridge.x+bridge.width/2,y:100});
    aiElixir-=card.cost;
  }
},2000);

// Elixir regen
setInterval(()=>{
  playerElixir=Math.min(playerElixir+1,MAX_ELIXIR);
  aiElixir=Math.min(aiElixir+1,MAX_ELIXIR);
  updateElixir();
},2800);

// Game loop
function gameLoop(){
  updateUnits(playerUnits, aiUnits, towers);
  updateUnits(aiUnits, playerUnits, towers);
  requestAnimationFrame(gameLoop);
}
gameLoop();
</script>
</body>
</html>
