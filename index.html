<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clash Royale Lite</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #87CEEB;
    overflow: hidden;
    height: 100%;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #4CAF50;
    border: 2px solid #000;
  }
  #ui {
    position: absolute;
    bottom: 20px;
    width: 100%;
    text-align: center;
  }
  #elixirBar {
    width: 250px;
    height: 18px;
    background: #ccc;
    border: 2px solid #333;
    margin: 0 auto;
    border-radius: 10px;
    overflow: hidden;
    position: relative;
  }
  #elixirFill {
    width: 0%;
    height: 100%;
    background: purple;
    transition: width 0.3s;
  }
  #elixirText {
    color: white;
    position: absolute;
    top: -25px;
    left: 50%;
    transform: translateX(-50%);
    font-weight: bold;
    font-size: 18px;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">
  <div id="elixirBar">
    <div id="elixirFill"></div>
    <div id="elixirText">0</div>
  </div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// Automatically scale to screen
function resizeCanvas() {
  canvas.width = window.innerWidth * 0.9;
  canvas.height = window.innerHeight * 0.9;
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

// Map layout
const map = {
  get width() { return canvas.width; },
  get height() { return canvas.height; },
  get riverY() { return this.height / 2; }
};

// Tower setup
let towers = [];

function resetTowers() {
  const w = map.width, h = map.height;
  towers = [
    // AI towers
    { x: w / 2, y: h * 0.08, hp: 5000, side: "enemy", main: true },
    { x: w / 2 - 100, y: h * 0.18, hp: 2000, side: "enemy" },
    { x: w / 2 + 100, y: h * 0.18, hp: 2000, side: "enemy" },
    // Player towers
    { x: w / 2, y: h * 0.92, hp: 5000, side: "player", main: true },
    { x: w / 2 - 100, y: h * 0.82, hp: 2000, side: "player" },
    { x: w / 2 + 100, y: h * 0.82, hp: 2000, side: "player" }
  ];
}
resetTowers();

// Elixir system
let elixir = 5;
let maxElixir = 10;
let elixirTimer = 0;

// Troops
let troops = [];

function spawnTroop(side, type, x, y) {
  let stats = {
    knight: { hp: 400, dmg: 60, speed: 1.6 },
    giant: { hp: 1200, dmg: 25, speed: 1.0 },
    archer: { hp: 200, dmg: 40, speed: 1.8 }
  }[type];
  troops.push({ ...stats, type, side, x, y, maxHp: stats.hp, target: null });
}

// AI logic
function aiLogic() {
  if (Math.random() < 0.02) {
    const laneX = Math.random() < 0.5 ? map.width * 0.35 : map.width * 0.65;
    const troopType = Math.random() < 0.6 ? "knight" : "giant";
    spawnTroop("enemy", troopType, laneX, map.height * 0.25);
  }
}

function update(delta) {
  // Elixir regen
  elixirTimer += delta;
  if (elixirTimer > 2.8) {
    elixir = Math.min(maxElixir, elixir + 1);
    elixirTimer = 0;
  }

  // Troop AI
  troops.forEach(t => {
    let enemies = troops.filter(e => e.side !== t.side);
    let enemyTowers = towers.filter(e => e.side !== t.side);
    let candidates = t.type === "giant" ? enemyTowers : enemies.concat(enemyTowers);
    t.target = candidates.sort((a,b) => Math.hypot(a.x - t.x, a.y - t.y) - Math.hypot(b.x - t.x, b.y - t.y))[0];
    if (!t.target) return;

    let dx = t.target.x - t.x;
    let dy = t.target.y - t.y;
    let dist = Math.hypot(dx, dy);

    // Avoid river unless near bridges
    const river = map.riverY;
    const nearBridge = (Math.abs(t.x - map.width * 0.25) < 60 || Math.abs(t.x - map.width * 0.75) < 60);
    if ((t.y < river - 25 && t.target.y > river + 25) ||
        (t.y > river + 25 && t.target.y < river - 25)) {
      if (!nearBridge) return;
    }

    if (dist > 20) {
      t.x += (dx / dist) * t.speed;
      t.y += (dy / dist) * t.speed;
    } else {
      t.target.hp -= t.dmg * delta * 0.5;
    }
  });

  troops = troops.filter(t => t.hp > 0);
  towers = towers.filter(t => t.hp > 0);
}

function draw() {
  const w = map.width, h = map.height, riverY = map.riverY;

  // Field
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = "#4CAF50";
  ctx.fillRect(0, 0, w, h);
  // River
  ctx.fillStyle = "#1E90FF";
  ctx.fillRect(0, riverY - 20, w, 40);
  // Bridges
  ctx.fillStyle = "#8B4513";
  ctx.fillRect(w * 0.25 - 40, riverY - 8, 80, 16);
  ctx.fillRect(w * 0.75 - 40, riverY - 8, 80, 16);

  // Towers
  towers.forEach(t => {
    ctx.fillStyle = t.side === "player" ? "#0000FF" : "#FF0000";
    ctx.fillRect(t.x - 15, t.y - 30, 30, 30);
    ctx.fillStyle = "white";
    ctx.font = "10px Arial";
    ctx.fillText(Math.floor(t.hp), t.x - 15, t.y - 35);
  });

  // Troops
  troops.forEach(t => {
    ctx.fillStyle = t.side === "player" ? "#2222FF" : "#FF2222";
    if (t.type === "giant") ctx.fillStyle = "#DAA520";
    ctx.beginPath();
    ctx.arc(t.x, t.y, 10, 0, Math.PI * 2);
    ctx.fill();
    // HP bar
    ctx.fillStyle = "red";
    ctx.fillRect(t.x - 10, t.y - 18, 20, 3);
    ctx.fillStyle = "lime";
    ctx.fillRect(t.x - 10, t.y - 18, 20 * (t.hp / t.maxHp), 3);
  });
}

// Game loop
let last = 0;
function loop(ts) {
  const delta = (ts - last) / 1000;
  last = ts;
  aiLogic();
  update(delta);
  draw();
  document.getElementById("elixirFill").style.width = (elixir / maxElixir) * 100 + "%";
  document.getElementById("elixirText").innerText = Math.floor(elixir);
  requestAnimationFrame(loop);
}

canvas.addEventListener("click", e => {
  if (elixir >= 5) {
    spawnTroop("player", Math.random() < 0.5 ? "knight" : "giant", e.offsetX, e.offsetY);
    elixir -= 5;
  }
});

requestAnimationFrame(loop);
</script>
</body>
</html>
