<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clash Royale Lite (Full View)</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #87CEEB;
    overflow: hidden;
    height: 100%;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #4CAF50;
    border: 2px solid #000;
  }
  #ui {
    position: absolute;
    bottom: 20px;
    width: 100%;
    text-align: center;
  }
  #elixirBar {
    width: 250px;
    height: 18px;
    background: #ccc;
    border: 2px solid #333;
    margin: 0 auto;
    border-radius: 10px;
    overflow: hidden;
    position: relative;
  }
  #elixirFill {
    width: 0%;
    height: 100%;
    background: purple;
    transition: width 0.3s;
  }
  #elixirText {
    color: white;
    position: absolute;
    top: -25px;
    left: 50%;
    transform: translateX(-50%);
    font-weight: bold;
    font-size: 18px;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">
  <div id="elixirBar">
    <div id="elixirFill"></div>
    <div id="elixirText">0</div>
  </div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// Resize canvas to fill screen
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

// Map setup
const baseWidth = 800;
const baseHeight = 1200;
let towers = [];
let troops = [];

// Scale factor for zooming out
function getScale() {
  // smaller factor = more zoomed out
  return Math.min(canvas.width / baseWidth, canvas.height / baseHeight) * 0.7;
}

// Reset towers
function resetTowers() {
  towers = [
    // Enemy
    { x: baseWidth / 2, y: baseHeight * 0.08, hp: 5000, side: "enemy", main: true },
    { x: baseWidth / 2 - 100, y: baseHeight * 0.18, hp: 2000, side: "enemy" },
    { x: baseWidth / 2 + 100, y: baseHeight * 0.18, hp: 2000, side: "enemy" },
    // Player
    { x: baseWidth / 2, y: baseHeight * 0.92, hp: 5000, side: "player", main: true },
    { x: baseWidth / 2 - 100, y: baseHeight * 0.82, hp: 2000, side: "player" },
    { x: baseWidth / 2 + 100, y: baseHeight * 0.82, hp: 2000, side: "player" }
  ];
}
resetTowers();

// Elixir
let elixir = 5, maxElixir = 10, elixirTimer = 0;

// Spawn troop
function spawnTroop(side, type, x, y) {
  const stats = {
    knight: { hp: 400, dmg: 60, speed: 1.6 },
    giant: { hp: 1200, dmg: 25, speed: 1.0 }
  }[type];
  troops.push({ ...stats, side, type, x, y, maxHp: stats.hp, target: null });
}

// AI
function aiLogic() {
  if (Math.random() < 0.02) {
    const laneX = Math.random() < 0.5 ? baseWidth * 0.35 : baseWidth * 0.65;
    const troopType = Math.random() < 0.6 ? "knight" : "giant";
    spawnTroop("enemy", troopType, laneX, baseHeight * 0.25);
  }
}

// Update logic
function update(delta) {
  elixirTimer += delta;
  if (elixirTimer > 2.8) {
    elixir = Math.min(maxElixir, elixir + 1);
    elixirTimer = 0;
  }

  troops.forEach(t => {
    let enemies = troops.filter(e => e.side !== t.side);
    let enemyTowers = towers.filter(e => e.side !== t.side);
    let candidates = t.type === "giant" ? enemyTowers : enemies.concat(enemyTowers);
    if (candidates.length === 0) return;
    t.target = candidates.sort((a,b) => Math.hypot(a.x - t.x, a.y - t.y) - Math.hypot(b.x - t.x, b.y - t.y))[0];
    let dx = t.target.x - t.x, dy = t.target.y - t.y, dist = Math.hypot(dx, dy);
    if (dist > 20) {
      t.x += (dx / dist) * t.speed;
      t.y += (dy / dist) * t.speed;
    } else {
      t.target.hp -= t.dmg * delta * 0.5;
    }
  });

  troops = troops.filter(t => t.hp > 0);
  towers = towers.filter(t => t.hp > 0);
}

// Draw function
function draw() {
  const scale = getScale();
  ctx.save();
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.translate(canvas.width / 2, canvas.height / 2);
  ctx.scale(scale, scale);
  ctx.translate(-baseWidth / 2, -baseHeight / 2);

  // Field
  ctx.fillStyle = "#4CAF50";
  ctx.fillRect(0, 0, baseWidth, baseHeight);

  // River
  const riverY = baseHeight / 2;
  ctx.fillStyle = "#1E90FF";
  ctx.fillRect(0, riverY - 20, baseWidth, 40);

  // Bridges
  ctx.fillStyle = "#8B4513";
  ctx.fillRect(baseWidth * 0.25 - 40, riverY - 8, 80, 16);
  ctx.fillRect(baseWidth * 0.75 - 40, riverY - 8, 80, 16);

  // Towers
  towers.forEach(t => {
    ctx.fillStyle = t.side === "player" ? "#0000FF" : "#FF0000";
    ctx.fillRect(t.x - 15, t.y - 30, 30, 30);
    ctx.fillStyle = "white";
    ctx.font = "10px Arial";
    ctx.fillText(Math.floor(t.hp), t.x - 15, t.y - 35);
  });

  // Troops
  troops.forEach(t => {
    ctx.fillStyle = t.side === "player" ? "#2222FF" : "#FF2222";
    if (t.type === "giant") ctx.fillStyle = "#DAA520";
    ctx.beginPath();
    ctx.arc(t.x, t.y, 10, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "red";
    ctx.fillRect(t.x - 10, t.y - 18, 20, 3);
    ctx.fillStyle = "lime";
    ctx.fillRect(t.x - 10, t.y - 18, 20 * (t.hp / t.maxHp), 3);
  });

  ctx.restore();
}

// Main loop
let last = 0;
function loop(ts) {
  const delta = (ts - last) / 1000;
  last = ts;
  aiLogic();
  update(delta);
  draw();
  document.getElementById("elixirFill").style.width = (elixir / maxElixir) * 100 + "%";
  document.getElementById("elixirText").innerText = Math.floor(elixir);
  requestAnimationFrame(loop);
}

canvas.addEventListener("click", e => {
  const rect = canvas.getBoundingClientRect();
  const scale = getScale();
  const x = (e.clientX - rect.left - canvas.width / 2) / scale + baseWidth / 2;
  const y = (e.clientY - rect.top - canvas.height / 2) / scale + baseHeight / 2;
  if (elixir >= 5) {
    spawnTroop("player", Math.random() < 0.5 ? "knight" : "giant", x, y);
    elixir -= 5;
  }
});

requestAnimationFrame(loop);
</script>
</body>
</html>
