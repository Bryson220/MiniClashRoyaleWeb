<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clash Royale Lite Improved</title>
<style>
html, body {margin:0; padding:0; background:#2c7a2c; overflow:hidden; font-family:sans-serif;}
#gameContainer {position: relative; width: 500px; height: 900px; margin:auto; background:#7CFC00;}
canvas {display:block; background:linear-gradient(#3fa63f 40%, #2e8b57 50%, #3fa63f 60%);}
#ui {position:absolute; top:10px; left:50%; transform:translateX(-50%); color:white; text-align:center;}
#elixirBar {width:300px; height:20px; border:2px solid white; margin:5px auto; background:#222; border-radius:5px;}
#elixirFill {height:100%; background:violet; width:0%; border-radius:5px;}
#elixirCount {margin-top:2px;}
#cards {position:absolute; bottom:20px; left:50%; transform:translateX(-50%); display:flex; gap:10px;}
.card {width:70px; height:70px; border:2px solid white; border-radius:10px; background:#444; color:white; display:flex; justify-content:center; align-items:center; cursor:grab; font-weight:bold; font-size:14px; text-align:center;}
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="game" width="500" height="900"></canvas>
  <div id="ui">
    <div id="elixirBar"><div id="elixirFill"></div></div>
    <div id="elixirCount">Elixir: 5</div>
    <div>Player King HP: <span id="playerHP"></span> | AI King HP: <span id="aiHP"></span></div>
  </div>
  <div id="cards"></div>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const width = canvas.width, height = canvas.height;
const riverY = height/2;
const bridgeWidth = 80, bridgeGap = 150;

const towers = {
  player: {
    king: {x:width/2, y:height-80, hp:5000, isTower:true, type:"king", range:150, cooldown:0, active:false},
    left: {x:width/2-130, y:height-180, hp:2000, isTower:true, type:"princess", range:120, cooldown:0},
    right:{x:width/2+130, y:height-180, hp:2000, isTower:true, type:"princess", range:120, cooldown:0}
  },
  ai: {
    king: {x:width/2, y:80, hp:5000, isTower:true, type:"king", range:150, cooldown:0, active:false},
    left:{x:width/2-130, y:180, hp:2000, isTower:true, type:"princess", range:120, cooldown:0},
    right:{x:width/2+130, y:180, hp:2000, isTower:true, type:"princess", range:120, cooldown:0}
  }
};

let units=[], projectiles=[];
let elixir=5, aiElixir=5;
const elixirFill = document.getElementById("elixirFill");
const elixirCount = document.getElementById("elixirCount");
const playerHP = document.getElementById("playerHP");
const aiHP = document.getElementById("aiHP");

let lastSpawn=0, aiLastSpawn=0;
const elixirRate=2800; // slower elixir regen

// Cards
const cards = [
  {id:"knight", shape:"circle", color:"blue", speed:0.8, range:25, damage:50, hp:300, cost:3, target:"any", type:"melee"},
  {id:"archer", shape:"triangle", color:"cyan", speed:0.7, range:100, damage:35, hp:150, cost:3, target:"any", type:"ranged", attackSpeed:1000},
  {id:"giant", shape:"square", color:"orange", speed:0.5, range:25, damage:80, hp:1000, cost:5, target:"tower", type:"melee"}
];

// Create card UI
const cardsDiv = document.getElementById("cards");
cards.forEach(card=>{
  const div = document.createElement("div");
  div.className = "card";
  div.innerHTML = `<span>${card.id}</span>`;
  div.draggable = true;
  div.addEventListener("dragstart", e=>dragStart(e, card));
  cardsDiv.appendChild(div);
});

let draggingCard = null;
function dragStart(e, card){draggingCard=card;}
canvas.addEventListener("dragover", e=>e.preventDefault());
canvas.addEventListener("drop", e=>{
  e.preventDefault();
  if(!draggingCard || elixir<draggingCard.cost) return;
  const rect = canvas.getBoundingClientRect();
  let x = e.clientX - rect.left;
  let y = e.clientY - rect.top;
  if(y > height/2) spawnUnit("player", draggingCard, {x, y});
  draggingCard = null;
});

function spawnUnit(side, card, pos){
  const laneOffset = Math.random()*30-15;
  units.push({side, card, x:pos.x+laneOffset, y:pos.y, hp:card.hp, target:null, bridgeCrossed:false, lastAttack:0});
  if(side==="player") elixir -= card.cost;
  else aiElixir -= card.cost;
}

function updateElixir(dt){
  if(Date.now()-lastSpawn>elixirRate && elixir<10){elixir++; lastSpawn=Date.now();}
  if(Date.now()-aiLastSpawn>elixirRate && aiElixir<10){aiElixir++; aiLastSpawn=Date.now();}
  elixirFill.style.width = (elixir/10*100)+"%";
  elixirCount.textContent = "Elixir: "+elixir;
}

// Distance
function distance(a,b){return Math.hypot(a.x-b.x,a.y-b.y);}

// Find target (smarter AI)
function findTarget(unit){
  const enemies = units.filter(e=>e.side!==unit.side && e.y>=riverY-40 && e.y<=riverY+40?false:true); // avoid water
  let target = null, dist = Infinity;
  for(let e of enemies){ const d=distance(unit,e); if(d<dist){dist=d; target=e;} }

  const towerSet = unit.side==="player"?towers.ai:towers.player;
  const towerArr = [towerSet.left, towerSet.right, towerSet.king];
  for(let t of towerArr){
    const d=distance(unit,t); if(d<dist){dist=d; target=t;} 
  }
  if(unit.card.id==="giant") target = towerSet.left.hp>0?towerSet.left:towerSet.right.hp>0?towerSet.right:towerSet.king;
  return target;
}

function updateUnits(dt){
  for(let u of units){
    if(u.hp<=0){units.splice(units.indexOf(u),1); continue;}
    if(!u.bridgeCrossed){
      if(u.side==="player" && u.y>riverY-40) u.y-=u.card.speed*0.5;
      if(u.side==="ai" && u.y<riverY+40) u.y+=u.card.speed*0.5;
      if(Math.abs(u.y-riverY)<=40){
        if(Math.abs(u.x-width/2)<=bridgeGap/2) u.bridgeCrossed=true;
        else u.x += u.x<width/2?0.5:-0.5;
      }
      continue;
    }
    u.target = findTarget(u);
    if(u.target){
      const dx = u.target.x-u.x, dy=u.target.y-u.y;
      const d = Math.hypot(dx,dy);
      if(d>u.card.range){u.x+=dx/d*u.card.speed*0.3; u.y+=dy/d*u.card.speed*0.3;}
      else { // attack
        if(u.card.type==="melee") u.target.hp -= u.card.damage*dt/1000;
        else if(u.card.type==="ranged" && Date.now()-u.lastAttack>u.card.attackSpeed){ 
          u.target.hp -= u.card.damage*dt/1000; u.lastAttack=Date.now();
        }
      }
    }
  }
}

function drawHealthBar(x,y,cur,max){
  ctx.fillStyle="red"; ctx.fillRect(x-15,y-25,30,4);
  ctx.fillStyle="lime"; ctx.fillRect(x-15,y-25,30*(cur/max),4);
}

function draw(){
  ctx.clearRect(0,0,width,height);
  ctx.fillStyle="#3fa63f"; ctx.fillRect(0,0, width, riverY-40); 
  ctx.fillRect(0, riverY+40, width, height/2);
  ctx.fillStyle="#3b75ff"; ctx.fillRect(0, riverY-40, width, 80); // river
  ctx.fillStyle="#8b4513"; ctx.fillRect(width/2-bridgeGap/2-bridgeWidth/2, riverY-40, bridgeWidth, 80);
  ctx.fillRect(width/2+bridgeGap/2-bridgeWidth/2, riverY-40, bridgeWidth, 80);

  const allTowers = [...Object.values(towers.player), ...Object.values(towers.ai)];
  for(let t of allTowers){
    ctx.fillStyle = t.y>height/2?"blue":"red";
    if(t.type==="king") ctx.beginPath(),ctx.arc(t.x,t.y,20,0,Math.PI*2),ctx.fill();
    else ctx.fillRect(t.x-15,t.y-15,30,30);
    drawHealthBar(t.x,t.y,t.hp,(t.type==="king"?5000:2000));
  }

  for(let u of units){
    ctx.fillStyle = u.card.color;
    if(u.card.shape==="circle") ctx.beginPath(),ctx.arc(u.x,u.y,10,0,Math.PI*2),ctx.fill();
    if(u.card.shape==="square") ctx.fillRect(u.x-10,u.y-10,20,20);
    if(u.card.shape==="triangle") ctx.beginPath(),ctx.moveTo(u.x,u.y-10),ctx.lineTo(u.x-10,u.y+10),ctx.lineTo(u.x+10,u.y+10),ctx.closePath(),ctx.fill();
    drawHealthBar(u.x,u.y,u.hp,u.card.hp);
  }
}

function aiLogic(){
  if(aiElixir>=3+Math.random()*3 && Math.random()<0.05){
    const card = cards[Math.floor(Math.random()*cards.length)];
    if(aiElixir>=card.cost) spawnUnit("ai",card,{x:width/2, y:180}), aiElixir-=card.cost;
  }
}

let lastTime = performance.now();
function loop(t){
  const dt = t-lastTime; lastTime = t;
  updateElixir(dt);
  updateUnits(dt);
  aiLogic();
  draw();
  playerHP.textContent = Math.round(towers.player.king.hp);
  aiHP.textContent = Math.round(towers.ai.king.hp);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

canvas.addEventListener("click", ()=>{
  const card = cards[Math.floor(Math.random()*cards.length)];
  if(elixir>=card.cost) spawnUnit("player",card,{x:width/2, y:height-160}), elixir-=card.cost;
});
</script>
</body>
</html>
