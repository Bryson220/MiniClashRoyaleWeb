<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clash Royale Lite</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background-color: #87CEEB;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #4CAF50;
    border: 3px solid #000;
  }
  #ui {
    position: absolute;
    bottom: 20px;
    width: 100%;
    text-align: center;
  }
  #elixirBar {
    width: 300px;
    height: 20px;
    background: #ccc;
    border: 2px solid #333;
    margin: 0 auto;
    border-radius: 10px;
    overflow: hidden;
    position: relative;
  }
  #elixirFill {
    width: 0%;
    height: 100%;
    background: purple;
    transition: width 0.3s;
  }
  #elixirText {
    color: white;
    position: absolute;
    top: -25px;
    left: 50%;
    transform: translateX(-50%);
    font-weight: bold;
    font-size: 18px;
  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="500" height="900"></canvas>

<div id="ui">
  <div id="elixirBar">
    <div id="elixirFill"></div>
    <div id="elixirText">0</div>
  </div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// Map setup
const map = {
  width: canvas.width,
  height: canvas.height,
  riverY: canvas.height / 2,
};

// Towers
const towers = [
  // Enemy side
  { x: canvas.width / 2, y: 70, hp: 5000, side: "enemy", main: true },
  { x: canvas.width / 2 - 100, y: 180, hp: 2000, side: "enemy" },
  { x: canvas.width / 2 + 100, y: 180, hp: 2000, side: "enemy" },
  // Player side
  { x: canvas.width / 2, y: canvas.height - 70, hp: 5000, side: "player", main: true },
  { x: canvas.width / 2 - 100, y: canvas.height - 180, hp: 2000, side: "player" },
  { x: canvas.width / 2 + 100, y: canvas.height - 180, hp: 2000, side: "player" },
];

// Elixir system
let elixir = 5;
let maxElixir = 10;
let elixirRate = 2.8;
let lastElixirGain = 0;

// Troops
let troops = [];

function spawnTroop(side, type, x, y) {
  let hp = type === "giant" ? 1200 : 400;
  let dmg = type === "giant" ? 25 : 60;
  let speed = type === "giant" ? 1.0 : 2.2;
  troops.push({ x, y, hp, maxHp: hp, type, side, dmg, speed, target: null });
}

// AI logic
function aiLogic() {
  if (Math.random() < 0.01) {
    const x = Math.random() < 0.5 ? 160 : 340;
    spawnTroop("enemy", Math.random() < 0.5 ? "knight" : "giant", x, 250);
  }
}

function draw() {
  // Field
  ctx.fillStyle = "#4CAF50";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // River
  ctx.fillStyle = "#1E90FF";
  ctx.fillRect(0, map.riverY - 25, canvas.width, 50);

  // Bridges
  ctx.fillStyle = "#8B4513";
  ctx.fillRect(90, map.riverY - 8, 80, 16);
  ctx.fillRect(330, map.riverY - 8, 80, 16);

  // Towers
  towers.forEach(t => {
    ctx.fillStyle = t.side === "player" ? "#3333FF" : "#FF3333";
    ctx.fillRect(t.x - 15, t.y - 30, 30, 30);
    ctx.fillStyle = "white";
    ctx.font = "10px Arial";
    ctx.fillText(Math.floor(t.hp), t.x - 15, t.y - 35);
  });

  // Troops
  troops.forEach(t => {
    ctx.fillStyle = t.type === "giant" ? "#DAA520" : (t.side === "player" ? "#0000FF" : "#FF0000");
    ctx.beginPath();
    ctx.arc(t.x, t.y, 10, 0, Math.PI * 2);
    ctx.fill();

    // HP bar
    ctx.fillStyle = "red";
    ctx.fillRect(t.x - 10, t.y - 18, 20, 3);
    ctx.fillStyle = "lime";
    ctx.fillRect(t.x - 10, t.y - 18, 20 * (t.hp / t.maxHp), 3);
  });
}

function update(delta) {
  lastElixirGain += delta;
  if (lastElixirGain > elixirRate) {
    elixir = Math.min(maxElixir, elixir + 1);
    lastElixirGain = 0;
  }

  // Troop AI
  troops.forEach(t => {
    let enemies = troops.filter(e => e.side !== t.side);
    let towersOnOtherSide = towers.filter(e => e.side !== t.side);

    if (!t.target || t.target.hp <= 0) {
      let targets = t.type === "giant" ? towersOnOtherSide : enemies.concat(towersOnOtherSide);
      t.target = targets.sort((a, b) =>
        Math.hypot(a.x - t.x, a.y - t.y) - Math.hypot(b.x - t.x, b.y - t.y)
      )[0];
    }

    if (t.target) {
      let dx = t.target.x - t.x;
      let dy = t.target.y - t.y;
      let dist = Math.hypot(dx, dy);

      // avoid river unless near bridges
      const nearLeftBridge = Math.abs(t.x - 130) < 80;
      const nearRightBridge = Math.abs(t.x - 370) < 80;
      if (
        (t.y < map.riverY - 25 && t.target.y > map.riverY + 25) ||
        (t.y > map.riverY + 25 && t.target.y < map.riverY - 25)
      ) {
        if (!nearLeftBridge && !nearRightBridge) return;
      }

      if (dist > 20) {
        t.x += (dx / dist) * t.speed;
        t.y += (dy / dist) * t.speed;
      } else {
        t.target.hp -= t.dmg * delta * 0.5;
      }
    }
  });

  troops = troops.filter(t => t.hp > 0);
}

let last = 0;
function gameLoop(ts) {
  const delta = (ts - last) / 1000;
  last = ts;
  update(delta);
  aiLogic();
  draw();

  document.getElementById("elixirFill").style.width = (elixir / maxElixir) * 100 + "%";
  document.getElementById("elixirText").innerText = Math.floor(elixir);

  requestAnimationFrame(gameLoop);
}

canvas.addEventListener("click", e => {
  if (elixir >= 5) {
    spawnTroop("player", Math.random() < 0.5 ? "knight" : "giant", e.offsetX, e.offsetY);
    elixir -= 5;
  }
});

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
