<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clash Royale Replica (Canvas Build)</title>
<style>
  html,body { margin:0; padding:0; background:#222; height:100%; overflow:hidden; }
  #gameCanvas { display:block; margin:auto; background:#4caf50; }
  #ui {
    position:absolute; bottom:20px; left:50%; transform:translateX(-50%);
    display:flex; gap:12px;
  }
  .card {
    width:80px; height:100px; background:#eee; border-radius:8px;
    font-family:sans-serif; display:flex; align-items:center; justify-content:center;
    cursor:pointer; transition:.2s;
  }
  .card:hover { transform:translateY(-6px); }
  #elixirBarContainer {
    position:absolute; bottom:140px; left:50%; transform:translateX(-50%);
    width:200px; height:28px; background:#555; border-radius:8px; overflow:hidden;
  }
  #elixirBar { height:100%; background:linear-gradient(to right,#5ec7ff,#1e6dbd); width:50%; }
  #elixirVal {
    position:absolute; bottom:170px; left:50%; transform:translateX(-50%);
    font-family:sans-serif; color:white; font-weight:bold;
  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="540" height="960"></canvas>
<div id="elixirVal">5</div>
<div id="elixirBarContainer"><div id="elixirBar"></div></div>
<div id="ui"></div>

<script>
// ---- Canvas Setup ----
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

// ---- Arena Layout ----
const riverHeight = 100;
const bridgeWidth = 100, bridgeHeight = 20;
const bridgeY = H/2 - bridgeHeight/2;
const bridgeOffsets = [W/4 - bridgeWidth/2, 3*W/4 - bridgeWidth/2];

// ---- Towers ----
const towers = [
  // Enemy
  {x:W/4-25,y:80,team:'enemy',hp:2000,type:'princess'},
  {x:3*W/4-25,y:80,team:'enemy',hp:2000,type:'princess'},
  {x:W/2-35,y:20,team:'enemy',hp:5000,type:'king'},
  // Player
  {x:W/4-25,y:H-130,team:'player',hp:2000,type:'princess'},
  {x:3*W/4-25,y:H-130,team:'player',hp:2000,type:'princess'},
  {x:W/2-35,y:H-80,team:'player',hp:5000,type:'king'}
];

// ---- Troops ----
const troops = [];
const cardDefs = [
  {id:'knight',cost:3,hp:300,dmg:10,speed:45,color:'#888'},
  {id:'archer',cost:2,hp:180,dmg:7,speed:60,color:'#f66'},
  {id:'giant',cost:5,hp:800,dmg:20,speed:30,color:'#fcb040'}
];

// ---- Elixir ----
let elixir = 5, maxElixir = 10, lastTick = 0;

// ---- UI ----
const ui = document.getElementById('ui');
let selectedCard = null;
cardDefs.forEach((c,i)=>{
  const div=document.createElement('div');
  div.className='card';
  div.textContent=c.id;
  div.onclick=()=>selectedCard=i;
  ui.appendChild(div);
});

// ---- Helpers ----
function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y);}
function drawArena(){
  // Top grass
  ctx.fillStyle="#3b9c3f";
  ctx.fillRect(0,0,W,(H-riverHeight)/2);
  // River
  ctx.fillStyle="#4db8ff";
  ctx.fillRect(0,(H-riverHeight)/2,W,riverHeight);
  // Bottom grass
  ctx.fillStyle="#3b9c3f";
  ctx.fillRect(0,(H+riverHeight)/2,W,(H-riverHeight)/2);
  // Bridges
  ctx.fillStyle="#a37c40";
  for(const x of bridgeOffsets){
    ctx.fillRect(x,bridgeY,bridgeWidth,bridgeHeight);
  }
}

function drawTowers(){
  for(const t of towers){
    ctx.fillStyle=t.team==='player'?'#2e7d32':'#b71c1c';
    const h=t.type==='king'?70:50;
    ctx.fillRect(t.x,t.y,50,h);
    // HP bar
    ctx.fillStyle='#000';
    ctx.fillRect(t.x,t.y-8,50,6);
    ctx.fillStyle='#0f0';
    ctx.fillRect(t.x,t.y-8,50*(t.hp/(t.type==='king'?5000:2000)),6);
  }
}

function drawTroops(){
  for(const tr of troops){
    ctx.beginPath();
    ctx.fillStyle = tr.team==='player'?tr.color:'#ff4444';
    ctx.arc(tr.x,tr.y,10,0,Math.PI*2);
    ctx.fill();
  }
}

function updateTroops(dt){
  for(const tr of troops){
    // Giant targets towers only
    let targets = towers.filter(t=>t.team!==tr.team);
    if(tr.id!=='giant'){
      // include enemy troops
      targets = targets.concat(troops.filter(t=>t.team!==tr.team));
    }
    let closest=null,min=99999;
    for(const t of targets){
      const d = dist(tr,t);
      if(d<min){min=d;closest=t;}
    }
    if(!closest) continue;
    if(min>20){
      const dx=closest.x-tr.x, dy=closest.y-tr.y;
      const d=Math.hypot(dx,dy);
      tr.x += dx/d*tr.speed*dt;
      tr.y += dy/d*tr.speed*dt;
    } else {
      closest.hp -= tr.dmg*dt;
      if(closest.hp<=0){
        if(closest.type) towers.splice(towers.indexOf(closest),1);
        else troops.splice(troops.indexOf(closest),1);
      }
    }
  }
}

function draw(){
  ctx.clearRect(0,0,W,H);
  drawArena();
  drawTowers();
  drawTroops();
}

function loop(ts){
  const dt = (ts-lastTick)/1000;
  if(ts - lastTick > 2800){
    elixir = Math.min(maxElixir, elixir+1);
    document.getElementById('elixirBar').style.width = (elixir/maxElixir*100)+'%';
    document.getElementById('elixirVal').textContent = Math.floor(elixir);
    lastTick = ts;
  }
  updateTroops(dt);
  draw();
  requestAnimationFrame(loop);
}

// ---- Placement ----
canvas.addEventListener('click', e=>{
  if(selectedCard==null) return;
  const rect=canvas.getBoundingClientRect();
  const x=(e.clientX-rect.left)*(W/rect.width);
  const y=(e.clientY-rect.top)*(H/rect.height);
  const card=cardDefs[selectedCard];
  if(elixir<card.cost || y< H/2) return; // player side only
  elixir-=card.cost;
  document.getElementById('elixirBar').style.width=(elixir/maxElixir*100)+'%';
  document.getElementById('elixirVal').textContent=Math.floor(elixir);
  troops.push({id:card.id,team:'player',x,y,hp:card.hp,dmg:card.dmg,speed:card.speed,color:card.color});
  selectedCard=null;
});

// ---- Enemy AI ----
setInterval(()=>{
  const c=cardDefs[Math.floor(Math.random()*cardDefs.length)];
  if(elixir>c.cost){
    troops.push({id:c.id,team:'enemy',x:W/2,y:200,hp:c.hp,dmg:c.dmg,speed:c.speed,color:c.color});
  }
},4000);

drawArena();
requestAnimationFrame(loop);
</script>
</body>
</html>
