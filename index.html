<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clash Royale Lite</title>
<style>
  body {
    margin: 0;
    background: #87CEEB;
    overflow: hidden;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #4caf50;
    border: 3px solid #333;
  }
  .ui {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 10px;
  }
  .card {
    width: 70px;
    height: 90px;
    background: #ddd;
    border-radius: 10px;
    border: 2px solid #333;
    text-align: center;
    font-family: sans-serif;
    font-size: 14px;
    cursor: pointer;
    user-select: none;
  }
  .selected {
    border-color: gold;
    background: #fff6a8;
  }
  .elixir-container {
    position: absolute;
    bottom: 110px;
    left: 50%;
    transform: translateX(-50%);
    text-align: center;
    font-family: sans-serif;
    color: white;
  }
  .elixir {
    width: 250px;
    height: 18px;
    border: 2px solid #fff;
    border-radius: 10px;
    background: #555;
    overflow: hidden;
    margin-top: 4px;
  }
  .elixir-fill {
    height: 100%;
    background: purple;
    width: 0%;
    transition: width 0.4s linear;
  }
</style>
</head>
<body>
<canvas id="game" width="450" height="700"></canvas>

<div class="elixir-container">
  <div id="elixirText">Elixir: 10</div>
  <div class="elixir">
    <div class="elixir-fill" id="elixirFill"></div>
  </div>
</div>

<div class="ui">
  <div class="card" id="knightCard">‚öîÔ∏è<br>Knight<br>3</div>
  <div class="card" id="archerCard">üèπ<br>Archer<br>3</div>
  <div class="card" id="giantCard">üí™<br>Giant<br>5</div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const WIDTH = canvas.width;
const HEIGHT = canvas.height;

const riverY = HEIGHT / 2 - 25;
const bridgeWidth = 70;

let troops = [];
let aiTroops = [];
let elixir = 10;
let selectedCard = null;
let lastElixirTime = Date.now();

const towers = {
  playerKing: {x: WIDTH/2 - 25, y: HEIGHT - 80, w: 50, h: 50, hp: 5000},
  playerLeft: {x: WIDTH/2 - 120, y: HEIGHT - 160, w: 35, h: 35, hp: 2000},
  playerRight: {x: WIDTH/2 + 85, y: HEIGHT - 160, w: 35, h: 35, hp: 2000},
  enemyKing: {x: WIDTH/2 - 25, y: 30, w: 50, h: 50, hp: 5000},
  enemyLeft: {x: WIDTH/2 - 120, y: 120, w: 35, h: 35, hp: 2000},
  enemyRight: {x: WIDTH/2 + 85, y: 120, w: 35, h: 35, hp: 2000},
};

const troopTypes = {
  Knight: {color: "blue", hp: 400, damage: 40, range: 20, speed: 0.9, cost: 3, target: "any"},
  Archer: {color: "purple", hp: 250, damage: 30, range: 100, speed: 1.2, cost: 3, target: "any"},
  Giant: {color: "orange", hp: 900, damage: 80, range: 15, speed: 0.6, cost: 5, target: "tower"}
};

class Troop {
  constructor(type, x, y, isAI) {
    Object.assign(this, troopTypes[type]);
    this.type = type;
    this.x = x;
    this.y = y;
    this.isAI = isAI;
    this.hp = this.hp;
  }
  draw() {
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, 12, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "red";
    ctx.fillRect(this.x - 12, this.y - 20, 24, 4);
    ctx.fillStyle = "lime";
    ctx.fillRect(this.x - 12, this.y - 20, 24 * (this.hp / troopTypes[this.type].hp), 4);
  }
  update() {
    const enemies = this.isAI ? troops : aiTroops;
    const enemyTowers = Object.values(towers).filter(t => this.isAI ? t.y > HEIGHT/2 : t.y < HEIGHT/2);
    let targets = (this.target === "any") ? enemies.concat(enemyTowers) : enemyTowers;
    let closest = this.findClosest(targets);
    if (!closest) return;
    const dx = closest.x - this.x;
    const dy = closest.y - this.y;
    const dist = Math.hypot(dx, dy);

    if (dist > this.range + 8) {
      const nx = dx / dist;
      const ny = dy / dist;
      // prevent water crossing except bridge
      if ((this.isAI && this.y < riverY + 25) || (!this.isAI && this.y > riverY + 35)) {
        if (Math.abs(this.x - WIDTH/2) < bridgeWidth/2) {
          this.x += nx * this.speed;
          this.y += ny * this.speed;
        }
      } else {
        this.x += nx * this.speed;
        this.y += ny * this.speed;
      }
    } else {
      closest.hp -= this.damage * 0.05;
    }
  }
  findClosest(targets) {
    let min = Infinity, closest = null;
    for (const t of targets) {
      const dx = (t.x + (t.w || 0)/2) - this.x;
      const dy = (t.y + (t.h || 0)/2) - this.y;
      const d = Math.hypot(dx, dy);
      if (d < min) { min = d; closest = t; }
    }
    return closest;
  }
}

function drawMap() {
  ctx.fillStyle = "#4caf50";
  ctx.fillRect(0, 0, WIDTH, HEIGHT);
  ctx.fillStyle = "#3399ff";
  ctx.fillRect(0, riverY, WIDTH, 50);
  ctx.fillStyle = "#8b5a2b";
  ctx.fillRect(WIDTH/2 - bridgeWidth/2, riverY, bridgeWidth, 50);
}

function drawTowers() {
  for (const [key, t] of Object.entries(towers)) {
    ctx.fillStyle = key.includes("player") ? "#555" : "#a00";
    ctx.fillRect(t.x, t.y, t.w, t.h);
    ctx.fillStyle = "red";
    ctx.fillRect(t.x, t.y - 6, t.w, 4);
    ctx.fillStyle = "lime";
    ctx.fillRect(t.x, t.y - 6, t.w * (t.hp / (key.includes("King") ? 5000 : 2000)), 4);
  }
}

function gameLoop() {
  ctx.clearRect(0, 0, WIDTH, HEIGHT);
  drawMap();
  drawTowers();

  troops.forEach(t => t.update());
  aiTroops.forEach(t => t.update());
  troops.forEach(t => t.draw());
  aiTroops.forEach(t => t.draw());

  troops = troops.filter(t => t.hp > 0);
  aiTroops = aiTroops.filter(t => t.hp > 0);

  // smarter AI spawning
  if (Math.random() < 0.005 && aiTroops.length < 6) {
    const type = Math.random() < 0.5 ? "Knight" : (Math.random() < 0.8 ? "Archer" : "Giant");
    aiTroops.push(new Troop(type, WIDTH/2 + (Math.random()*100-50), 100 + Math.random()*50, true));
  }

  // elixir regeneration
  const now = Date.now();
  if (now - lastElixirTime > 2800 && elixir < 10) {
    elixir += 1;
    lastElixirTime = now;
  }
  document.getElementById('elixirFill').style.width = (elixir * 10) + "%";
  document.getElementById('elixirText').innerText = "Elixir: " + elixir;

  requestAnimationFrame(gameLoop);
}
gameLoop();

// troop placement
canvas.addEventListener('click', e => {
  if (!selectedCard) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  if (y > HEIGHT/2 + 40 && elixir >= troopTypes[selectedCard].cost) {
    troops.push(new Troop(selectedCard, x, y, false));
    elixir -= troopTypes[selectedCard].cost;
  }
});

// card selection
function selectCard(type) {
  selectedCard = type;
  document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
  document.getElementById(type.toLowerCase() + 'Card').classList.add('selected');
}
document.getElementById('knightCard').onclick = () => selectCard("Knight");
document.getElementById('archerCard').onclick = () => selectCard("Archer");
document.getElementById('giantCard').onclick = () => selectCard("Giant");
</script>
</body>
</html>
